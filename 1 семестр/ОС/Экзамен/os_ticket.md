#### Билеты

1. [Модель фон Неймана и прерывания.]()
2. [Понятие и структура операционной системы.]()
3. [Назначение, состав и функции ОС.]()
4. [Классификация и примеры современных ОС.]()
5. [Понятие и назначение ядра ОС.]()
6. [Структура ядра современных ОС.]()
7. [Управление виртуальной памятью.]()
8. [Стратегии подкачек и вытеснения страниц памяти.]()
9. [Программы, процессы и потоки.]()
10. [Кооперативная и вытесняющая многозадачность.]()
11. [Планировщики задач с приоритетами.]()
12. [Основные примитивы синхронизации потоков.]()
13. [Проблема тупиков (deadlocks) и способы борьбы с ней.]()
14. [Гармонически взаимодействующие процессы.]()
15. [Механизмы межзадачного взаимодействия.]()
16. [Классификация внешних устройств.]()
17. [Драйверы внешних устройств.]()
18. [Файлы, каталоги и файловые системы.]()
19. [Основные структуры файловых систем.]()
20. [Идентификация пользователей и права доступа.]()
21. [Виды атак на операционные системы.]()
22. [Иерархия классов безопасных систем.]()
23. [Многоуровневые системы безопасности.]()
24. [Проблема тайных ходов в операционной системе.]()

#### Ответы
##### Модель фон Неймана и прерывания
Принципы Фон Неймана

+ Неизменность архитектуры

1. Принцип двоичного кодирования
  
   Вся информация поступающая в ЭВМ кодируются двоичным кодом
2. Принцип однородности памяти
  * Программа и данные в одном памяти *(пристонская архитектура)*
  * В разной памяти *(нарвардская архитектура)*

  Программы и данные хранятся в одной и той же памяти  поэтому ЭВМ не различает , что храниться в данной  ячейке памяти – число , тест или команда . над командами можно выполнить такие же действия, как и над данными 
3. Принцип адресуемости памяти

    ОП представляет собой набор ячеек, каждая из которых имеет уникальный  номер – адрес ячейки, время доступа к ячейке не зависит от её адреса
4. Принцип программного управления

    Программа состоит из набора команд которые выполняются процессом автоматически друг за другом в определенной последовательности 
    
    **Процессор находится в бесконечном цикле из двух половинок:**
    
    1. **Выборка и декодирование** – выбирает очередную команду из оперативной памяти и пытается её понять (декодирует)
    2. **Исполнение** – в процессоре есть специальный регистр IP – адрес следующей команды. (Без IP невозможны for, if и т.д., а возможны только линейные программы.)

    Команды перехода меняют IP.
5. Прерывания
    Если произошло событие нарушающее работу процессора, происходит прерывание, при этом текущее состояние процессора сохраняется, а в IP записывается другой адрес
    
    Есть 3 типа прерываний:
    
    1. Внутреннее прерывание – вызывает сам процессор *(деление на 0)*
    2. Внешнее прерывание – вызывается устройствами ввода-вывода. Обрабатывает прерывания контроллер прерываний.
    3. Программное прерывание – прерывание, вызывающееся программистом.
      
Согласно фон Нейману ЭВМ состоит из следующих основных блоков

*	процессор состоящий из устройства управления, через которые идет поток команд и данных и арифметическо – логического устройства, производящего арифметические и логические операции
*	устройства ввода и устройства вывода информации – внешние (периферийные) устройства 
*	запоминающие устройства - память в том числе оперативная и внешнее запоминающее устройства 

##### Понятие и структура операционной системы
Базовые понятия операционной системы
Для каждой ОС существует набор базовых понятий:
*	процессы
*	память
*	файлы

ОС - это набор программ, обеспечивающих управление ресурсами. (Ресурсы – оборудование, время, файлы, безопасность, права пользователя (всё, от чего зависит работа компьютера, что можно дать или отнять))

Структура ОС:
1. Операционная оболочка
2. ОС:

  * Прикладные программы
  * API (Applied Program interface) – интерфейс прикладных программ. (Набор системных функций и подпрограмм)
  * Ядро ОС (содержит планировщик; драйверы устройств, непосредственно управляющие оборудованием; сетевую подсистему, файловую систему;)

3. Реальная машина

Мы работаем с виртуальной машиной,
Операционная оболочка – это пользовательский интерфейс (их может быть множество на одной ОС), она обеспечивает надежность и эффективность. 

Многозадачность и распределение полномочий требуют определённой иерархии привилегий компонентов самой ОС.

Есть 2 режима работы процессора:

*	Привилегированный (режим ядра). В привилегированном режиме можно все (выполнять любые команды и получать доступ к любой области памяти)
*	Пользовательский. В пользовательском режиме ряд команд нельзя выполнять, и ограничен доступ к памяти.

*Мы работаем с виртуальной машиной, ОО – пользовательский интерфейс ОС*
*	Надежность
*	Эффективность

====

* IBM OS/360, OS/370 – первые полноценные ОС
* DEC – лидер в области минимашин

  PDP 8x 16x машины
  
  VAX 32x
  
  PDP-11 RT-11 (операционная система реального времени)
  
* RSX-11 – система общего назначения
* VAX/VMS – virtual machine system
* БЭСМ-6, Эльбрус

Еще была система Multics от Bell Labs (Дейкстра). Той же командой позже был создан UNIX (70-е гг).

Переход UNIX на С (с ассемблера, видимо).

POSIX – стандарт на разработку ОС. Есть 2 части, вторая нестарндартизована.

Современные системы UNIX: коммерческие (IBM – AIPX, SUN – Solaris, HP – HPUX), остальные (FreeBSD, Linux)

Windows 9x: 95, 98, Me; Windows NT: 2000, XP, 2003 Server; Windows CE (Mobile).

Ныне Unix на 70% контролируют рынок больших машин, Windows почти полностью рынок PC.

##### Назначение, состав и функции ОС.
***Главное назначение ОС*** - это управление ресурсами, а главные ресурсы, которыми она управляет - это аппаратура компьютера, она управляет процессорами, памятью, устройствами ввода-вывода и данными.

Функции

ОС реализует множество различных функций, в том числе:
* Загрузка приложений в оперативную память и их выполнение
* Стандартизованный доступ к периферийным устройствам (устройства ввода-вывода)
* Управление оперативной памятью (распределение между процессами, виртуальная память)
* Управление энергонезависимой памятью (Жёсткий диск, Компакт-диск и т. д.), как правило с помощью файловой системы
* Пользовательский интерфейс
* Организация взаимодействия задач друг с другом
* Взаимодействие пользовательских программ с нестандартными внешними устройствами
* Организация межмашинного взаимодействия и разделения ресурсов
*	Прием от пользователя заданий, команд, сформулированных на соответствующем языке и их обработка
*	Обеспечение загрузки пользовательских программ в оперативную память и их исполнение
*	Распределение памяти, а в большинстве современных систем и организация виртуальной памяти
*	Организация параллельного выполнения двух и более программ на одном процессоре, создающая видимость их одновременного исполнения
*	Защита одной программы от влияния другой, обеспечение сохранности данных, защита самой ОС от исполняющихся на компьютере приложений
*	Аутентификация и авторизация пользователей
определяет так называемый интерфейс пользователя,
* Обеспечивает разделение аппаратных ресурсов между пользователями,
* Дает возможность работать с общими данными в режиме коллективного пользования,
* Планирует доступ пользователей к общим ресурсам,
* Осуществляет восстановление информации и вычислительного процесса в случае ошибок.

Состав:
*	BIOS *(выполнение наиболее простых и универсальных услуг ОС)*
*	Загрузчик ОС *(находится в первом секторе жесткого диска, она выбирает, из какого из разделов жесткого диска следует продолжать загрузку.)*
*	Дисковые файлы IO.SYS и MSDOS.SYS SYS *(IO.SYS представляет собой дополнение к базовой системе ввода-вывода в ПЗУ. MSDOS.SYS реализует основные высокоуровневые услуги ОС.)*
*	Командный процессор *(обрабатывает команды, вводимые пользователем. Командный процессор находится в файле COMMAND.COM)*
*	Внешние команды *(поставляемые вместе с ОС в виде отдельных файлов, Эти программы выполняют действия обслуживающего характера, например, форматирование дискет, проверку дисков и т.д.)*
*	Драйверы устройств *(это специальные программы, которые дополняют систему ввода-вывода ОС и обеспечивают обслуживание новых или нестандартное использование имеющихся устройств. Драйверы загружаются в память компьютера при загрузке ОС, их имена указываются в специальном файле CONFIG.SYS)*

Главное назначение ОС - это управление ресурсами, а главные ресурсы, которыми она управляет, - это аппаратура компьютера она управляет процессорами, памятью, устройствами ввода-вывода и данными.

**Вообще, ОС - это довольно расплывчатое понятие, опирающееся на определенные традиции, параметры оборудования, размеры программ, реализующих определенные функции, а также распределение**

##### Классификация и примеры современных ОС
1. Неполноценные ОС. 

  Выполняют часть функций: обеспечивают работу устройств, предоставляют пользовательский интерфейс, управляют файловой системой, запускают 1 программу. *(Дисковые ОС) (MS DOS)*
2. 	Операционные системы общего назначения.

  1. Системы пакетной обработки
  2. ОС с разделением времени 
  
  Рассчитанные на интерактивную работу одного или нескольких пользователей в режиме разделения времени.

  Система разделяет время процессора между пользователями. Системы становятся псевдопараллельными.
3. ОС рельного времени. 

  Способность гарантировать время реакции является отличительным признаком систем РВ. *программа бортового компьютера*

  Система для управления оборудованием. Отличие: гарантированное время отклика на внешнее воздействие. Есть одна оперативная задача (критичная по времени отклика) и фоновые задачи.
4. Системы виртуальных машин

   это ОС, допускающая одновременную работу нескольких программ, но создающая при этом для каждой программы иллюзию того, что машина находится в полном ее распоряжении, как при работе под управлением ДОС.) *MS DOS и MS Windows-эмуляторы для UNIX и OS/2*
5.	Системы промежуточных типов

  системы, которые нельзя отнести к одному из вышеперечисленных классов. *Windows 95*
  
Классификация:

1.	Однозадачные. Операционная система поддерживает не более одного приложения запущенного в конкретный момент. MS-DOS
2.	Многозадачные - ОС создаёт иллюзию нескольких одновременно рабочих приложений. В системе есть системный таймер, который управляет распределением процессорного времени между приложениями.
  1.	Кооперативная многозадачность. Приложения сами отдают управление supervisor'y тогда, когда сочтут нужным. Т.е. программа может забрать управление себе и не отдавать, после чего система превращается в однозадачную. *Win 3.11*
  2.	Вытесняющая многозадачность. Управление отбирается у приложений по внешним прерываниям.
    1. Реального времени - гарантирует отклик на все события за фиксированное время. 
    2. Разделения времени - управление переходит к supervisor'y по системному таймеру, после чего тот по своей "шаманской" формуле определяет, кому снова отдать управление. *WinXP, Win9x*

Операционные системы могут различаться особенностями реализации внутренних алгоритмов управления основными ресурсами компьютера (процессорами, памятью, устройствами), особенностями использованных методов проектирования, типами аппаратных платформ, областями использования и многими другими свойствами, например: *Поддержка многопользовательского режима.* 

По числу одновременно работающих пользователей ОС делятся на: 
* однопользовательские (MS-DOS, Windows 3.x, ранние версии OS/2)
* многопользовательские (UNIX, Windows NT)

Главным отличием многопользовательских систем от однопользовательских является наличие средств защиты информации каждого пользователя от несанкционированного доступа других пользователей. 

##### Понятие и назначение ядра ОС
Ядро - часть ОС, которая работает в привилегированном режиме.

Там находятся: 
1. все, что связано c вводом, выводом
2.	команды прерываний
3.	команды системного управления процессором

Все операции, связанные с процессами, выполняются под управлением этой части ОС.

Ядро обычно размещается в оперативной памяти, в то время как другие части ОС перемещаются во внешнюю память и обратно по мере необходимости.

Функции ядра
Ядро ОС, как правило, должно содержать программы для реализации следующих функций:
*	обработка прерываний;
*	операции над процессами;
*	синхронизация процессов;
*	организация взаимодействия между процессами;
*	манипулирование блоками управления процессами;
*	поддержка операций ввода-вывода;
*	поддержка работы файловой системы;
*	поддержка механизма вызова-возврата при обращении к процедурам;
*	ряд учетных функций.

##### Структура ядра современных ОС
Ядро состоит из трех основных подсистем:
* Файловая подсистема;

	  Файловая подсистема контролирует права доступа к файлу, выполняет операции размещения и удаления файла, а также выполняет запись/чтение данных файла. Поскольку большинство прикладных функций выполняется через интерфейс файловой системы, права доступа к файлам определяют привилегии пользователя в системе.
	  
	  Файловая подсистема обеспечивает перенаправление запросов, адресованных периферийным устройствам, соответствующим модулям подсистемы ввода/вывода.
* Подсистема управления процессами и памятью;
  * Создание и удаление процессов;
  * Распределение системных ресурсов (памяти, вычислительных ресурсов) между процессами;
  * Синхронизация процессов;
  * межпроцессорное взаимодействие.
* Подсистема ввода/вывода

  Подсистема ввода/вывода выполняет запросы файловой подсистемы и подсистемы управления процессами для доступа к периферийным устройствам (дискам, терминалам и т.п.). Она обеспечивает необходимую буферизацию данных и взаимодействует с драйверами устройств - специальными модулями ядра, непосредственно обслуживающими внешние устройства.

##### Управление виртуальной памятью
Виртуальная память была создана, потому что оперативной памяти(ОП) не хватает, а так каждой программе, работающей в компьютере, выделяется 4Гб виртуальной памяти. Реально ее не существует, её создает ОС. Эта память поделена на две части (чаще всего пополам): память программы (младшая) и память ядра и всех его таблиц (старшая). Из старшей памяти ничего нельзя даже считать.

Суть концепции виртуальной памяти заключается в том, что адреса, к которым обращается выполняющийся процесс, отделяются от адресов, реально существующих в физической памяти. 

Несмотря на то, что процессы обращаются только к виртуальным адресам, в действительности они должны работать с реальной памятью, таким образом, во время выполнения процесса виртуальные адреса необходимо преобразовывать в реальные, причем это необходимо делать быстро, чтобы не снижалась производительность вычислительной машины.

Управление памятью можно представлять, как отображение информации в память посредством трех функций
*	Именующей функции f1, однозначно отображающей данное пользователем имя в идентификатор информации, к которой это имя относится.
* Функции памяти f2, отображающей однозначно определенные идентификаторы в истинные адреса памяти, в которых они находятся.
* Функции содержимого f3 ,отображающей каждый адрес памяти в значение, которое по этому адресу находится. 

*Имена заданные потльзователеи* -> **f1** -> *Однозначные идентификаторы* -> **f2** -> *Ячейки в памяти* -> **f3** -> *Значения*

Термин виртуальная память обычно ассоциируется с возможностью адресовать пространство памяти, гораздо большее, чем емкость первичной (реальной, физической) памяти конкретной вычислительной машины.

##### Стратегии подкачек и вытеснения страниц памяти
И виртуальная и физическая (ОП) памяти разбиваются на *страницы* – это блок фиксированного размера.

Поэтому виртуальную память называют еще и страничной виртуальной памятью.

Передача информации между памятью и диском всегда осуществляется целыми страницами. Так виртуальным адресам ставится в соответствие некий адрес физической памяти. Система отображения виртуальных адресов в физические сводится к  системе отображения виртуальных страниц в физические и представляет собой *таблицу дескрипторов (таблицу страниц)*.

Однажды может случится, что ОП закончится, тогда делается следующее:
* Если ОС поддерживает виртуальную память, то она имеет файл-подкачки (хранится на жестком диске). Среди страниц, которые заняты (в физической памяти) ядро произвольно выбирает страницу, копирует её в файл-подкачки, а страница становится свободной и тогда виртуальная память отображает страницу на освободившуюся. Если нам нужна страница, которая уже выброшена, то выбрасывается новая «жертва», а на освободившуюся страницу копируется страница из файла-подкачки (т.е. с жесткого диска.
 * Windows – pagefile.sys является файлом-подкачки.
 * Linux – не файл, а раздел диска swap. (жесткий диск работает медленнее ОЗУ, поэтому это нежелательно)

Алгоритм выбора «жертвы»
1.	Не требующий поддержки процессора (основан на запоминании выделения страниц)
Например, последовательное (жертвой делаем первого) и кольцевое (меняем расположение головы-начала).
2.	С историей, *дополнительными битами*
 
  Предполагается, что в каждой странице вирт. памяти есть 2 дополнительных бита R и M.

  R – выставляется 1, если страницу хоть раз читали
  
  M - выставляется 1, если в нее хоть раз записывали 
  
  (00-идеальная жертва, 11-худший вариант)
3.	Комбинированный вариант (с битами и по времени)

При выгружении не могут выгрузиться:
* Обработчик прерываний
*	Менеджер безопасности
*	Менеджер процессов
*	Менеджер виртуальной памяти
*	Менеджер потоков

Это тот минимум, который нужен для работы процессора

##### Программы, процессы и потоки.
Программа и процесс – это не одно и то же. 

*Программа* — последовательность формализованных инструкций, предназначенная для исполнения устройством управления вычислительной машины, она записана на жестком диске

*Процесс* –  Программа прочитана и размещена в ОП.

  С каждым процессом связывается его адресное пространство, из которого он может читать и в которое он может писать данные, пространство содержит: саму программу, данные к программе и стек программы.
  
*Потоки* – это выполнение процесса.

***Выполняющимся (активным)*** *потоком* - называется поток управления, обрабатываемый в данный момент процессором. В многопроцессорных конфигурациях может одновременно выполняться несколько потоков.

*Поток* управления считается *готовым* к выполнению, если он способен стать активным, но не может этого сделать из-за отсутствия свободного процессора.

В Windows есть два типа потоков:

*	UI-threads – пользовательский интерфейс
*	Working threads – рабочие потоки

Новый процесс всегда создается другим процессом. Первый процесс всегда запускается вместе с ОС. В UNIX порождающая функция fork – порождает копию родительского процесса, в котором потом меняются код и данные. В Windows – CreateProcess, создается сразу нужный процесс. fork позволяет иметь общую часть кода у экземпляров одной программы. В Windows если запустить 100 раз word, то будет 100 его копий в памяти. В Windows нет иерархии процессов, все процессы самостоятельные. В UNIX есть чёткая иерархия процессов.
Права процесса = права порожд. процесса пересечь с правами текущего пользователя.
Ни в UNIX, ни в Windows завершение процесса не приводит к завершению дочерних процессов, но завершение процесса приводит к уничтожению всех его потоков. Демоны и сервисы – потоки, которые выполняются и без родительского процесса.

Завершение процесса – это завершение всех его потоков.

1.	Нормальное завершение потока – все сделал
2.	Нормальное завершение по ошибке (из-за невозможности дальше выполняться)
3.	Фатальная ошибка, не предусмотренная программистом
4.	Насильное завершение потока ОС

Один процесс может породить множество потоков, которые будут выполняться параллельно.

Параллельность достигается за счет разделения времени между потоками, это позволяет сделать системный таймер – это некий кварцевый генератор:

Происходит прерывание, попадает в ядро, в обработчик прерываний. В  ядре счетчик, когда достигает определенного числа, сохраняет предыдущее состояние и переключается на другой поток.

Разделение времени зависит от приоритета, чем выше приоритет, тем больше времени дается. Кто долго работает должен иметь низкий приоритет.

*Поток управления* называют *вытесненным*, когда его выполнение приостановлено из-за того, что другой поток с более высоким приоритетом уже готов к выполнению.

*Процесс (поток управления)* считается *блокированным*, если для продолжения его выполнения должно стать истинным некоторое условие, отличное от доступности процессора.


##### Кооперативная и вытесняющая многозадачность.
*Многозадачность* — свойство операционной системы или среды программирования, обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких процессов. 

* Вытесняющая – Вид многозадачности, в котором операционная система сама передает управление от одной выполняемой программы другой. Распределение процессорного времени осуществляется планировщиком процессов. Этот вид многозадачности обеспечивает более быстрый отклик на действия пользователя. *(Windows 95, Windows NT, Windows 2000, Unix)*
* Кооперативная – Тип многозадачности, при котором фоновые задачи выполняются только во время простоя основного процесса и только в том случае, если на это получено разрешение основного процесса. *(Все управление отдано системе. В такой системе легче программировать, но она менее эффективна.) (Windows 3.1, Macintosh)*

Реализация:
* Кооперативная многозадачность

  Обработав очередное сообщение, приложение передает управление операционной системе, которая может передать управление другому приложению.
* Вытесняющая многозадачность

  Все существующие в данный момент потоки, часть из которых может принадлежать одному и тому же процессу, претендуют на процессорное время и, с точки зрения пользователя должны выполняться одновременно. Для создания этой иллюзии система через определенные промежутки времени забирает управление, анализирует свою очередь сообщений, распределяет сообщения по другим очередям в пространстве процессов и, если считает нужным, переключает потоки

##### Планировщики задач с приоритетами
Самым простым и наиболее распространенным способом распределения процессов по приоритетам является организация нескольких очередей в соответствии с приоритетами. При этом процесс из низкоприоритетной очереди получает управление тогда и только тогда, когда все очереди с более высоким приоритетом пусты.

***Приоритеты***

Приоритеты могут быть статическими или динамическими

*Статические приоритеты* не изменяются, такой механизм установки приоритетов достаточно прост и не сопряжен с большими издержками. Однако следует учитывать, что такой механизм недостаточно гибок, т.к. не реагирует на изменение окружающей ситуации.

*Динамические приоритеты* (в современных ОС) позволяют повысить реактивность системы, т.к. реагируют на изменения ситуации, и начальное значение приоритета процесса может быть изменено на новое, более подходящее значение. Он изменяется в зависимости от того, насколько активно задачу использует процессор и другие системные ресурсы.

Предпочтительными для системы будут те программы, которые захватывают процессор на короткое время и быстро отдают его, переходя в состояние ожидания внешнего или внутреннего события. Таким процессам система стремится присвоить более высокий приоритет. 

Таким образом, система динамически повышает приоритет тем заданиям, которые освободили процессор в результате запроса на ввод-вывод или ожидание события и, наоборот, снижает тем заданиям, которые были сняты по истечении кванта времени. (Чем дольше программа работает, тем меньше у нее приоритет, затем он резко возрастает до прежнего уровня и так циклично, пока работает поток)


##### Основные примитивы синхронизации потоков
В одном процессе может выполняться сколько угодно потоков, а если есть несколько потоков, то их нужно синхронизировать.
```
int n=0, f=0;
while (true) {	
 while (!f);
 n++, n++;
 f=0;
}		    
while(true) {
 while (f);
 if (n…)
 f=1;
}

```
минусы данной синхронизации:
* впустую тратится энергия и процессорное время
* если переменных больше одной, то возникнут трудности

При выполнении параллельных процессов может возникать проблема, когда каждый процесс, обращающийся к разделяемым данным, исключает для всех других процессов возможность одновременного с ним обращения к этим данным - это называется взаимоисключением

Поэтому современные ОС содержат такое понятие mutex (взаимное исключение) это позволяет чтобы потоки выполнялись непрерывно – это обычный флажок.

С mutex возможны 2 операции: lock(m)- заблокировать и unlock(m)- разблокировать. Это обуславливает поочередный доступ к общему ресурсу. 

Mutex – это частный случай «Семафора». В основе семафора  – счетчик n.

При каждом захвате из счетчика вычитается 1, когда станет 0 – следующий захват заблокирует всех. «Семафор» нужен для защиты однородных ресурсов. Таким образом, синхронизация решается методом поочередной блокировки с помощью семафора и mutex. 

Не все виды синхронизации решаются данным способом, поэтому существует второй вид – синхронизация по времени (должно произойти некоторое событие, которого дожидается программа). Для этого используется «условная переменная» q-war (Unix), event (Windows).  С этим понятием можно использовать две операции: wait (E) - ждать сигнал  и Signal (E) - послать сигнал, причем события не гарантируют, что потоки не проспят сигнал.

**Основные примитивы синхронизации потоков.**

Выполняющимся (активным) называется поток управления, обрабатываемый в данный момент процессором. В многопроцессорных конфигурациях может одновременно выполняться несколько потоков.

Поток управления считается готовым к выполнению, если он способен стать активным, но не может этого сделать из-за отсутствия свободного процессора.

Поток – модель параллельного произведения нескольких действий.

1 процесс может породить множество потоков, которые будут выполняться параллельно.

Параллельность достигается за счет разделения времени между потоками.

Переключение потоков происходит за счет системного таймера 18.2 р. в с. Происходит прерывание, попадает в ядро, в обработчик прерываний. В ядре счетчик, когда достигает определенного числа, сохраняет предыдущее состояние и переключается на другой поток.

Разделение времени, чем выше приоритет, тем времени дается больше. Кто долг работает должен иметь низкий проритет.
Поток управления называют вытесненным, когда его выполнение приостановлено из-за того, что другой поток с более высоким приоритетом уже готов к выполнению.

Процесс (поток управления) считается блокированным, если для продолжения его выполнения должно стать истинным некоторое условие, отличное от доступности процессора.

Список потоков управления – это упорядоченный набор готовых к выполнению равноприоритетных потоков, очередность которых определяется политикой планирования. Множество наборов включает все потоки в системе, готовые к выполнению.

Можно определять начало и конец параллельного выполнения (распараллеливание потоков)

##### Проблема тупиков и способы борьбы с ней

Предположим, что несколько процессов конкурируют за обладание конечным числом *ресурсов*. Если запрашиваемый процессом *ресурс* недоступен, ОС переводит данный процесс в состояние ожидания. В случае, когда требуемый *ресурс* удерживается другим ожидающим процессом, первый процесс не сможет сменить свое состояние. Такая ситуация называется **тупиком**. Говорят, что процесс находится в состоянии *тупика*, если он ожидает события, которое никогда не произойдет. Иногда подобные ситуации называют **взаимоблокировками**. В общем случае проблема тупиков эффективного решения не имеет.

Условия возникновения тупиков были сформулированы Коффманом, Элфиком и Шошани в 1970
1. Условие взаимоисключения. Одновременно использовать ресурс может только один процесс. 
2. Условие ожидания ресурсов. Процессы удерживают ресурсы, уже выделенные им, и могут запрашивать другие ресурсы. 
3. Условие неперераспределяемости. Ресурс, выделенный ранее, не может быть принудительно забран у процесса. Освобождены они могут быть только процессом, который их удерживает. 
4. Условие кругового ожидания. Существует кольцевая цепь процессов, в которой каждый процесс ждет доступа к ресурсу, удерживаемому другим процессом цепи.

Для образования тупика необходимым и достаточным является выполнение всех четырех условий.

Способы борьбы с взаимоблокировками
*	Игнорирование проблемы в целом 
*	Предотвращение тупиков 
*	Обнаружение тупиков 
*	Восстановление после тупиков

Простейший подход – не замечать проблему тупиков. Для того чтобы принять такое решение, необходимо оценить вероятность возникновения взаимоблокировки и сравнить ее с вероятностью ущерба от других отказов аппаратного и программного обеспечения. Проектировщики обычно не желают жертвовать производительностью системы или удобством пользователей для внедрения сложных и дорогостоящих средств борьбы с тупиками.
Можно избежать взаимоблокировки, если распределять ресурсы, придерживаясь определенных правил. Среди такого рода алгоритмов наиболее известен алгоритм банкира, который базируется на так называемых безопасных или надежных состояниях. Безопасное состояние – это такое состояние, для которого имеется, по крайней мере, одна последовательность событий, которая не приведет к взаимоблокировке. Модель алгоритма основана на действиях банкира, который, имея в наличии капитал, выдает кредиты.
Суть алгоритма состоит в следующем.
* Предположим, что у системы в наличии n устройств, например лент. 
* ОС принимает запрос от пользовательского процесса, если его максимальная потребность не превышает n. 
* Пользователь гарантирует, что если ОС в состоянии удовлетворить его запрос, то все устройства будут возвращены системе в течение конечного времени. 
* Текущее состояние системы называется надежным, если ОС может обеспечить всем процессам их выполнение в течение конечного времени. 
* В соответствии с алгоритмом банкира выделение устройств возможно, только если состояние системы остается надежным.
Условия ожидания ресурсов можно избежать, потребовав выполнения стратегии двухфазного захвата. 
* В первой фазе процесс должен запрашивать все необходимые ему ресурсы сразу. До тех пор пока они не предоставлены, процесс не может продолжать выполнение. 
* Если в первой фазе некоторые ресурсы, которые были нужны данному процессору, уже заняты другими процессами, он освобождает все ресурсы, которые были ему выделены, и пытается повторить первую фазу.

##### Гармонически взаимодействующие процессы
Гармоническое взаимодействие
* либо не взаимодействуют
* либо взаимодействуют в строго определенных точках кода программ

Эта концепция состоит в следующем: 
*	Каждый процесс представляет собой независимый программный модуль, для которого создается иллюзия чисто последовательного исполнения.
*	Процессы не имеют разделяемых данных.
*	Все обмены данными, и вообще взаимодействие, происходят в выделенных точках процессов. В этих точках процесс, передающий данные, останавливается и ждет, пока его партнер будет готов эти данные принять. Аналогично, процесс, принимающий данные, ожидает, пока ему передадут данные. 
*	Синхронизация, не сопровождающаяся передачей данных, просто лишена смысла - процессы, не имеющие разделяемых структур данных, совершенно независимы.

Концепция гармонически взаимодействующих процессов очень привлекательна с теоретической точки зрения и позволяет легко писать правильные программы. Однако часто по соображениям производительности оказывается невозможно отказаться от разделяемой памяти.

##### Механизмы межзадачного взаимодействия
Труба (Pipe) – универсальный инструмент передачи информации между процессами.

Это при условии, что в современных ОС программы изолированы друг от друга.

Pipe – временный файл, позволяющий общаться программам.

Pipe бывают двух видов: 
*	безымянные (односторонние, только чтение и запись, строго последовательные)
*	именованные (двусторонние, операции создать, открыть, закрыть, читать, решать и т. д., если труба пустая, то заблокируется пока туда ничего не запишут) В этом виде существует проблема, что имена совпадут, но универсального способа борьбы с этим не существует.

Итак, труба – это основной механизм общения программ.

Кроме труб, существует ещё один вид  взаимодействия: «почтовые ящики» (Unix – mailbox, Windows - mailslot)

«Почтовый ящик» – область ОП (32-64 Кб), поэтому быстрая, но маленькая. Используется, если нужно послать сообщение сразу многим. Если ящик полон, то при новом письме выталкиваем самое старое
Отличия:
* труба, доставка с гарантией
* почтовый ящик, без гарантий 

##### Классификация внешних устройств

1.	Классификация по значению
  1.	ввода
  2.	вывода
  3.	устройства внешней памяти
    *	Магнитные накопители (ленты, магнитные и жесткие диски)
    *	Оптические накопители (лазером, CD, DVD)
    *	Флэш-устройства (минерализация – представляет собой кристалл, который поляризуется)
  4.	cвязные устройства (сетевые карты, модемы)
2.	По передаче данных
  1.	символьные
  2.	блочные
3.	По доступу
  1.	произвольное
  2.	последовательное

##### Драйверы внешних устройств
Драйвер устройства – это программа, которая обеспечивает управление устройством, т.е. позволяющая конкретному устройству взаимодействовать с операционной системой.

Если устройство включено в список совместимого оборудования, то драйвер такого устройства обычно входит в состав Windows. 

Драйверы устройств загружаются автоматически при запуске компьютера и с этого момента выполняются, оставаясь невидимыми.
Plug and Play – автоматически ищет драйвера для подключённого устройства. Идея: воткнуть новое устройство, во время загрузки обнаруживается, ищется драйвер, загружается и все работает.

Горячее подключение – USB.

Большинство ОС запрещают пользовательским программам непосредственный доступ к аппаратуре. Это делается для повышения надежности и обеспечения безопасности в многопользовательских системах.

Чаще всего драйверы являются частью ядра системы, исполняются в высшем кольце защиты и имеют доступ на запись к сегментам данных пользовательских программ, а часто и к данным самого ядра, т.е. драйверы всегда работают в режиме ядра.

Отсюда следующие уязвимости:
* могут повредить работе ядра
* их установка позволяет нам влезть внутрь ядра

##### Файлы, каталоги и файловые системы.
*Файл* – это именованный набор данных. Это место постоянного хранения информации: программ, данных для их работы, текстов, закодированных изображений, звуков и др.

*Файловая система* - это средство для организации хранения файлов на каком-либо носителе.

Задачи файловой системы
* уметь определить номера секторов по имени файла
* уметь находить свободные сектора

Каждый файл имеет имя, зарегистрированное в каталоге - оглавлении файлов. Каталог (иногда называется директорией или папкой) – это тоже по сути файл, только специальный.

Для выполнения команды «Открыть файл» драйвер файловой системы обращается к своему справочнику, выясняет, какие блоки диска соответствуют указанному файлу, а затем передает запрос на считывание этих блоков драйверу диска. 

##### Основные структуры файловых систем
*Файловая система* - это часть общей системы управления памятью, назначение которой сводится в основном к управлению файлами, хранящимися во внешней памяти, а также  к контролируемому разделению информации между пользователями.

Функции файловой системы
*	предоставление возможности создавать, модифицировать, уничтожать файлы;
*	контролируемое разделение файлов несколькими пользователями;
*	предоставление пользователю возможности задания различной структуры файлов и возможности управления передачей информации между файлами;
*	в системе должны быть предусмотрены средства обеспечения сохранности и восстановления информации в файлах;
*	система должна обеспечивать независимость файлов от внешних устройств;
*	система должна предоставлять защиту информации  в файлах от несанкционированнного доступа (возможность шифрования и дешифрования данных);
*	файловая система должна иметь “дружественный” интерфейс по отношению к пользователю.

Состав файловой системы

  Файловая система, входящая в состав ядра ОС, как правило, содержит следующие средства:
  *	Методы доступа к хранящимся в файлах.
  *	Средства управления файлами
  *	Средства управления внешней памятью, обеспечивающие распределение пространства внешней памяти для размещения файлов.
  *	Средства обеспечения целостности файлов, которые гарантируют сохранность информации файла.

Основные ФС
* Windows: FAT и NTFS.
* Linux: Ext2,3,4

##### Идентификация пользователей и права доступа
Идентификация пользователя происходит с помощью авторизации (пользователь должен сообщить ОС свои данные)

Способы авторизации:
*	имя, пароль (основной)
*	использование специальных устройств (магнитная карта и т.д.)
*	использование биологической информации о пользователе (отпечатки пальцев, сетчатка глаза)

Пароли не хранятся в открытом виде. Сильный пароль – не менее 8 символов, прчем различных видов (буквы, цифры, крючки). Пароль должен быть сложным и бессмысленным, чтобы его нельзя было подобрать.

Права пользователя (права доступа к файлам):
*	чтение
*	изменение
*	удаление
*	исполнение

Для хранения прав доступа к файлам используются таблица (матрица)

Права: R (Read), W(Write), E (exec), D (delete);

Таблицы могут быть:
*	Таблицы по пользователю - c-list.
*	По файлу – ACL (Access Control list).

Поскольку пользователей гораздо меньше, чем файлов, легче хранить права для каждого пользователя с самим файлом. Такая структура используется в большинстве ОС.

##### Виды атак на операционные системы.
Основные угрозы (приёмы нарушения безопасности) можно поделить на внешние и внутренние. Внешние – вирусы, черви и DoS-атаки.

* DoS-атака – попытка уронить машину, чтобы она перестала реагировать на внешние воздействия. Является сильным средством общественного влияния.
* Троян – обычная с виду программа, которая ничего не портит, но незаметно сливает информацию и посылает её кому-нибудь. Её цель – не быть замеченной.
* Логические бомбы – программы, проверяющие наличие некоторого условия, и при наличии совершающие некоторые действия. Особый вид логических бомб – чёрные ходы (отладочная информация, случайно или специально не убранная из программы).
* Фальшивые экраны логинов – при запуске системы заменяют экран логина своей программой, выглядящей так же, чтобы узнать логины-пароли всех пользователей.

##### Иерархия классов безопасных ОС 
Безопасность систем проранжирована в книге Orange Book. Безопасность ранжируется так: D, C1, C2, C3, B1, B2, A. Там же описано, что характеризует каждый уровень безопасности.

Система уровня A – безопасность системы можно доказать формально, теоретически в системе нет дырок. Пока таких нет.

B1 и B2 – военные, правительственные системы.

Большинство систем находятся в C. 

С1 – разбиение по группам

C2 – ACL, групповая политика.

C3 – минимальная безопасность (авторизация, пароли).

D – ОС без всякой безопасности. Все всё могут. (DOS)

Из сколь угодно надёжной системы можно воровать информацию, поскольку все тайные ходы не перекрыть. Так что система A1 должна обезопасить хотя бы от внешней угрозы.

##### Многоуровневые системы безопасности.
Многоуровневая безопасность состоит в наличии разных уровней секретности, при этом на каждом уровне происходит сужение круга лиц. У каждого пользователя есть ранг, чем он выше, тем прав больше. Есть 2 модели:

1.	N может читать все у рангов <= N, а писать рангам >= N.
   Здесь нарушается целостность прав.
2.	N может читать все у рангов >= N, а писать рангам <= N.
   Здесь есть целостность, но нет безопасности.

Обобщением подхода является организация ОС в виде  иерархии уровней. Первой системой, построенной таким образом, была система THE, созданная в Technische Hogeschool Eindhoven (Нидерланды) Э. Дейкстрой и его студентами в 1968 году. Она была простой пакетной системой для голландского компьютера Electrologica X8, память которого состояла из 32К 27-разрядных слов. 

Система включала 6 уровней. 

Структура операционной системы THE
```
5 Оператор
4 Программы пользователя
3 Управление вводом-выводом
2 Связь оператор-процесс
1 Управление памятью и барабаном
0 Распределение процессора и многозадачность
````

Уровень 0 занимался распределением времени процессора, переключая процессы при возникновении прерывания или при срабатывании таймера. Над уровнем 0 система состояла из последовательных процессов, каждый из которых можно было запрограммировать, не заботясь о том, что на одном процессоре запущено несколько процессов. Другими словами, уровень 0 обеспечивал базовую многозадачность процессора. Здесь есть целостность, но нет безопасности.


Уровень 1 управлял памятью. Он выделял процессам пространство в оперативной памяти и на магнитном барабане объемом 512К слов для тех частей процессов (страниц), которые не помещались в оперативной памяти. Процессы более высоких уровней не заботились о том, находятся ли они в данный момент в памяти или на барабане. Программное обеспечение уровня 1 обеспечивало попадание страниц в оперативную память по мере необходимости.

Уровень 2 управлял связью между консолью оператора и процессами. Таким образом, все процессы выше этого уровня имели свою собственную консоль оператора. 

Уровень 3 управлял устройствами ввода-вывода и буферизовал потоки информации к ним и от них. 
Любой процесс выше уровня 3, вместо того чтобы работать с конкретными устройствами, с их разнообразными особенностями, мог обращаться к абстрактным устройствам ввода-вывода, обладающим удобными для пользователя характеристиками. 

На уровне 4 работали пользовательские программы, которым не надо было заботиться ни о процессах, ни о памяти, ни о консоли, ни об управлении устройствами ввода-вывода.

Процесс системного оператора размещался на уровне 5.

##### Проблема тайных ходов в операционной системе
Сливание информации может осуществляться методом стеганографии – передачи информации поверх другой, защищённой.

Один из способов создания дыры в системе безопасности. Для этого в систему внедряется специальная программа, позволяющая обойти нормальную процедуру проверки. Например, программист модет добавить к программе регистрации кусок программы, пропускающий в систему пользователя с именем "zzzzzz", независимо от того, что содержится в файле паролей. Если пользователь ввел при регистрации это имя, то пароль уже не важен. Если такой потайной лаз установлен программистом, работающим на фирме, производящей компьютеры, а затем поставляется вместе с компьютерами, впоследствии этот программист сможет зарегистрироваться на любом компьютере, произведенном его компанией, независимо от того, кому будет принадлежать компьютер и какая информация будет содержаться в файле паролей. Потайная дверь просто обходит весь процесс аутентификации. 

Чтобы не допустить установки потайных дверей в систему, компании могут, например, ввести регулярные просмотры программ. При этом, когда программист закончил писать и тестировать программный модуль, модуль проверяется и помещается в базу данных. Периодически все программисты команды собираются вместе и каждый из них поочередно разъясняет остальным, что делает его программа, строка за строкой. При этом вероятность обнаружения потайных дверей значительно увеличивается. Кроме того, если программиста поймают за подобным занятием, то это не будет плюсом в его карьере. Если программисты слишком резко возражают против такой процедуры, можно поручить программистам проверку программ друг друга.

